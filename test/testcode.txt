struct tree
{
    root: node*
}

/* testowy komentarz */

struct node
{
    value: int 
    left: node* 
    right: node* 
}

const MAX_STACK = 1024

let stack := node*[MAX_STACK]
let last_node := &stack[0]

fn push_node(n: node*)
{
    if (last_node < &(stack[MAX_STACK - 1]) - 1)
    {
        last_node++
        *last_node = n
    }
}

fn pop_node(): node* 
{
    if (last_node > &stack[0])
    {
        last_node--
        return *last_node
    }
    else
    {
        return 0
    }
}

fn _depth_first()
{
    let n : node* = pop_node()
    if (n)
    {
        if (n.right)
        {
            push_node(n.right)
        }
        if (n.left)
        {
            push_node(n.left)
        }       
        printf("%lld ", n.value)
    }
}

fn _depth_first_rec(n: node*)
{
    printf("%lld ", n.value)    
    if (n.left)
    {
        _depth_first_rec(n.left)
    }
    if (n.right)
    {
        _depth_first_rec(n.right)
    }
}

fn depth_first_traversal(t: tree*)
{    
    push_node(t.root)

    printf("tree depth first traversal: ")

    _depth_first_rec(t.root)
}

let cirular_queue : node*[MAX_STACK]
let max_index : int = MAX_STACK - 1
let first_index : int 
let last_index : int 
let element_count : int 

fn push_to_queue(n: node*)
{
    if (element_count < MAX_STACK)
    {
        cirular_queue[last_index] = n
        last_index++
        if (last_index > max_index)
        {
            last_index = 0
        }
        element_count++
    }
}

fn pop_from_queue(): node*
{
    if (element_count <= 0)
    {
        return 0
    }

    node* result = cirular_queue[first_index]
    element_count--
    first_index++
    if (first_index > max_index)
    {
        first_index = 0
    }
    return result
}

fn _breadth_first()
{
    node* n = pop_from_queue()
    printf("%lld ", n.value)
    if (n)
    {
        if (n.left)
        {
            push_to_queue(n.left)
        }
        if (n.right)
        {
            push_to_queue(n.right)
        }
    }
}

fn breadth_first_search(t: tree*)
{
    push_to_queue(t.root)

    printf("tree breadth first traversal: ")
    while (element_count > 0)
    {
        _breadth_first()
    }
}

fn search_for_value(n: node*, value: int): bool
{
    if (n == 0)
    {
        return false
    }
    else if (n.value == value)
    {
        return true
    }
    else if (search_for_value(n.left, value))
    {
        return true
    }
    else if (search_for_value(n.right, value))
    {
        return true
    }
    else
    {
        return false
    }
}

let max_depth: int
let current_depth: int

fn check_depth(n : node*)
{
    current_depth++
    if (n.left)
    {        
        check_depth(n.left)
    }
    if (n.right)
    {
        check_depth(n.right)        
    }
    current_depth--

    if (current_depth > max_depth)
    {
        max_depth = current_depth
    }
}

fn get_tree_depth(t: tree*): int
{
    max_depth = 0
    current_depth = 0

    check_depth(t.root)
    printf("tree depth: %lld", max_depth)

    return max_depth
}

let max_path_sum : int
let current_path_sum : int

fn check_path_sum(n: node*)
{
    if (n == NULL)
    {
        return
    }

    current_path_sum += n.value
    if (n.left)
    {
        check_path_sum(n.left)
    }
    if (n.right)
    {
        check_path_sum(n.right)
    }
    
    if (n.left == 0 && n.right == 0)    
    {
        if (current_path_sum > max_path_sum)
        {
            max_path_sum = current_path_sum
        }
    }
    current_path_sum -= n.value
}

fn get_max_path_sum(t: tree*): int
{
    max_path_sum = 0
    current_path_sum = 0

    check_path_sum(t.root)
    printf("tree max path sum: %lld", max_path_sum)

    return max_path_sum
}

fn invert_left_right(n: node*)
{
    if (n)
    {
        node* temp = n.right
        n.right = n.left
        n.left = temp

        invert_left_right(n.left)
        invert_left_right(n.right)
    }
}

fn invert_binary_tree(t: tree*)
{
    invert_left_right(t.root)
}

fn print_node(n: node*)
{
    printf("( %lld ", n.value)
    if (n.left)
    {
        print_node(n.left)
    }
    if (n.right)
    {
        print_node(n.right)
    }
    printf(")")
}

fn print_tree(t: tree*)
{
    print_node(t.root)
}

fn tree_test()
{
    let a : node = { 1 }
    let b : node = { 2 }
    let c : node = { 3 }
    let d : node = { 4 }
    let e : node = { 5 }
    let f : node = { 6 }
    let g : node = { 7 }
    let h : node = { 8 }

    a.left = &b
    a.right = &c
    b.left = &d
    b.right = &e
    d.left = &g
    d.right = &h
    c.right = &f

    let t: tree = { 0 }
    t.root = &a

    /*
               a
              /  \
             b    c
            / \    \
           d   e    f
          / \
         g   h
    */

    push_node(t.root)
    let result: node* = pop_node()
    assert(result == t.root)

    push_to_queue(&a)
    push_to_queue(&b)
    push_to_queue(&c)
    assert(pop_from_queue() == &a)
    assert(pop_from_queue() == &b)
    assert(pop_from_queue() == &c)

    breadth_first_search(&t)

    assert(search_for_value(t.root, 7))
    assert(false == search_for_value(t.root, 9))
    assert(false == search_for_value(t.root, 0))
    
    let depth: int = get_tree_depth(&t)
    assert(depth == 3)

    let sum: int = get_max_path_sum(&t)

    printf("original tree:\n\n")
    print_tree(&t)
    invert_binary_tree(&t)
    printf("inverted tree:\n\n")
    print_tree(&t)
}